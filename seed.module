<?php

/**
 * @file
 * Provides seeding functionality for modules.
 */

/**
 * Default seed category name.
 */
define('SEED_CATEGORY_NAME', 'Seeds');

/**
 * Default seed category vocabulary id.
 */
define('SEED_CATEGORY_DEFAULT_VID', 'seed_category_default_vid');

/**
 * Seed replant time.
 */
define('SEED_REPLANT_TIME', 60 * 5);

/**
 * Seed replant time.
 */
define('SEED_CULL_TIME', 60 * 5);

/**
 * Implements hook_menu().
 */
function seed_menu() {
  return array(
    'admin/config/people/seed' => array(
      'title' => 'Seeds',
      'description' => 'Configure seed settings.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('seed_admin_settings'),
      'access arguments' => array('administer seeds'),
      'file' => 'seed.admin.inc',
      'type' => MENU_NORMAL_ITEM,
    ),
    'admin/reports/seeds' => array(
      'title' => 'Seed status',
      'description' => 'View current seed status',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('seed_list'),
      'access arguments' => array('view seed reports'),
      'file' => 'seed.pages.inc',
      'type' => MENU_NORMAL_ITEM,
    ),
  );
}

/**
 * Implements hook_permission().
 */
function seed_permission() {
  return array(
    'administer seeds' => array(
      'title' => t('Administer Seeds'),
      'description' => t('Allows to create, read, update and destroy seeds.'),
    ),
    'use seeds' => array(
      'title' => t('Use seeds'),
      'description' => t('Allows to find and use seeds.'),
    ),
    'use seed test block' => array(
      'title' => t('Use seed test block'),
      'description' => t('View the seed testing block'),
    ),
    'view seed reports' => array(
      'title' => t('View seed reports'),
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function seed_block_info() {
  return array(
    'seed_test' => array(
      'info' => t('Seed Tester'),
      'cache' => DRUPAL_NO_CACHE,
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function seed_block_view($delta = '') {
  if ( $delta == 'seed_test' && user_access('use seed test block') ) {
    return array(
      'subject' => t('Seed Tester'),
      'content' => drupal_get_form('seed_test_form'),
    );
  }
}

/**
 * Seed testing form.
 */
function seed_test_form($form, &$form_state) {
  $seed = seed_find();

  $form['sid'] = array(
    '#type' => 'hidden',
    '#value' => isset($seed->sid) ? $seed->sid : 0,
  );

  $form['submit'] = array(
    '#disabled' => !isset($seed->sid),
    '#type' => 'submit',
    '#value' => isset($seed->sid) ? t('Seed @seedname Available', array('@seedname' => $seed->name)) : t('No seed available'),
  );

  return $form;
}

/**
 * Seed testing form submit callback.
 */
function seed_test_form_submit(&$form, &$form_state) {
  if ( $form_state['values']['sid'] !== 0 ) {
    $seed = seed_use($form_state['values']['sid']);
    drupal_set_message(t('Successfully used seed @seedname', array('@seedname' => $seed->name)));
  }
}

/**
 * Clear all seeds.
 */
function seed_clear_all() {
  db_truncate('seed')->execute();
  drupal_set_message(t('Cleared all seeds'));
}

/**
 * Generate seeds.
 */
function seed_generate($number_of_seeds = 10, $interval = 60, $tid = NULL) {
  seed_clear_all();

  $time = time();

  for ( $i = 1; $i <= $number_of_seeds; $i++ ) {
    $seed = (object) array(
      'tid' => $tid,
      'name' => 'generated' . $i,
      'seed_timestamp' => $time + ( $i * $interval ),
      'seed_timestamp_end' => $time + ( $i * $interval ) + 120,
      'hold_life' => 120,
      'replant' => 1,
      'status' => 1,
    );

    seed_save($seed);
  }

  drupal_set_message(t('Successfully generated @number_of_seeds seeds.', array('@number_of_seeds' => $number_of_seeds)));
}

/**
 * Find a seed.
 *
 * @param $tid
 *   A term id.
 * @param $hold
 *   Whether to hold the seed for the user.
 * @return
 *   A seed object, or FALSE if the seed is not found.
 */
function seed_find($tid = NULL, $hold = TRUE, $account = NULL) {
  return seed_find_process(array('tid' => $tid, 'hold' => $hold, 'account' => $account));
}

/**
 * Find a seed.
 *
 * @param $tid
 *   A term id.
 * @param $hold
 *   Whether to hold the seed for the user.
 * @return
 *   A seed object, or FALSE if the seed is not found.
 */
function seed_find_process($params = array()) {
  $params += array(
    'tid' => NULL,
    'hold' => TRUE,
    'time' => time(),
    'account' => $GLOBALS['user'],
  );

  if ( is_null($params['account']) ) {
    $params['account'] = $GLOBALS['user'];
  }

  // If account doesn't have access, stop now.
  if ( !seed_find_access($params['account']) ) {
    return FALSE;
  }

  // 1. Cultivate (or clean) out any old or stale seeds.
  seed_cultivate();

  // 2. Find a seed currently held by the user.
  $seed = seed_find_held($params);

  // 3. If no seed was found, look for a new seed without any limits.
  if ( $seed === FALSE ) {
    $query = db_select('seed', 's')
      ->fields('s', array())
      ->condition('s.status', 1)
      ->condition('s.seed_timestamp', $params['time'], '<')
      ->condition('s.seed_timestamp_end', 0)
      ->orderBy('s.seed_timestamp')
      ->range(0, 1);

    if ( !is_null($params['tid']) ) {
      $query->condition('s.tid', $params['tid']);
    }

    $seed = $query->execute()->fetchObject();
  }

  // 4. If no seed was found, look for a new seed with limits.
  if ( $seed === FALSE ) {
    $query = db_select('seed', 's')
      ->fields('s', array())
      ->condition('s.status', 1)
      ->condition('s.seed_timestamp', $params['time'], '<')
      ->condition('s.seed_timestamp_end', $params['time'], '>')
      ->orderBy('s.seed_timestamp')
      ->range(0, 1);

    if ( !is_null($params['tid']) ) {
      $query->condition('s.tid', $params['tid']);
    }

    $seed = $query->execute()->fetchObject();
  }

  // 5. If a seed was found, update some information on it.
  if ( $seed !== FALSE ) {

    // The first time the seed is found, send a watchdog notice.
    if ( $params['hold'] && $seed->uid == 0 ) {
      watchdog('seed', 'Seed @seedname was found by @username.', array('@seedname' => $seed->name, '@username' => $params['account']->name), WATCHDOG_NOTICE, l('user', 'user/' . $params['account']->uid));

      // Update seed to be marked as held.
      $seed->hold_timestamp = $params['time'];
      $seed->hold_timestamp_end = $params['time'] + $seed->hold_life;
      $seed->uid = $params['account']->uid;
      $seed->status = 0;
      seed_save($seed);
    }

    return $seed;
  }

  // 6. If we got this far, there wasn't a seed available.
  return FALSE;
}

/**
 * Cultivate (or clean) expired seeds.
 */
function seed_cultivate() {
  // Replant held seeds that have expired.
  if ( variable_get('seed_replant', TRUE) ) {
    seed_replant();
  }

  // Cull held seeds that have expired.
  if ( variable_get('seed_pluck', TRUE) ) {
    seed_pluck();
  }
}

/**
 * Replant seeds so they can be found again.
 */
function seed_replant() {
  $seeds_replanted = db_update('seed')
    ->fields(array('status' => 1, 'uid' => 0, 'hold_timestamp' => 0, 'hold_timestamp_end' => 0))
    ->condition('hold_timestamp_end', time(), '>')
    ->condition('replant', 1)
    ->condition('used', 0)
    ->condition('status', 0)
    ->execute();

  if ( $seeds_replanted > 0 ) {
    watchdog('seed', 'Replanted @seeds_replanted expired seeds.', array('@seeds_replanted' => $seeds_replanted), WATCHDOG_NOTICE);
  }
}

/**
 * Pluck expired seeds so the can't be found again.
 */
function seed_pluck() {
  $seeds_plucked = db_update('seed')
    ->fields(array('status' => 0, 'uid' => 0, 'used' => 1, 'used_timestamp' => time()))
    ->condition('hold_timestamp_end', time(), '>')
    ->condition('replant', 0)
    ->condition('used', 0)
    ->condition('status', 0)
    ->execute();

  if ( $seeds_plucked > 0 ) {
    watchdog('seed', 'Plucked @seeds_plucked expired seeds.', array('@seeds_plucked' => $seeds_plucked), WATCHDOG_NOTICE);
  }
}

/**
 * Find a seed currently being held by a user.
 *
 * @param $account
 *   A user object.
 * @return
 *   TRUE if a seed is found, FALSE otherwise.
 */
function seed_find_held($params) {
  dpm($params);

  $seed = db_select('seed', 's')
    ->fields('s', array())
    ->condition('s.uid', $params['account']->uid)
    ->condition('s.used', 0)
    ->condition('s.status', 0)
    ->orderBy('s.seed_timestamp')
    ->range(0, 1)
    ->execute()
    ->fetchObject();

  return $seed;
}



/**
 * Returns weather the account has access to find a seed.
 *
 * @param $account
 *   A user object.
 * @return
 *   TRUE if the account has access, otherwise FALSE
 */
function seed_find_access($account) {
  // Ensure user account has permission to use seeds.
  if ( !user_access('use seeds', $account) ) {
    return FALSE;
  }

  // Does the user have a role that is to be ignored?
  foreach ( variable_get('seed_ignored_roles', array()) as $id ) {
    if ( $id != 0 && array_key_exists($id, $account->roles) ) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Drop a seed.
 */
function seed_drop($sid) {
  global $user;

  if ( $seed = seed_load($sid, TRUE) ) {
    $account = user_load($seed->uid);

    $seed->status = 1;
    $seed->hold_timestamp = 0;
    $seed->uid = 0;

    seed_save($seed);

    watchdog('seed', 'Seed @seedname was dropped by @username.', array('@seedname' => $seed->name, '@username' => $account->name), WATCHDOG_NOTICE, l('user', 'user/' . $account->uid));

    return $seed;
  }

  // Something went wrong.
  watchdog('seed', 'unable to drop seed @sid for user @username', array('@sid' => $sid, '@username' => $user->name), WATCHDOG_CRITICAL, l('user', 'user/' . $user->uid));

  return FALSE;
}

/**
 * Use a held seeds and prevent it from being found in the future.
 *
 * @param $sid
 *   A seed id.
 * @return
 *   A seed object or FALSE if unable to use.
 */
function seed_use($sid) {
  global $user;

  if ( $seed = seed_load($sid, TRUE) ) {
    $account = user_load($seed->uid);

    if ( user_access('use seeds', $account) ) {
      $seed->used = TRUE;
      $seed->used_timestamp = time();
      $seed->used_token = seed_use_token($seed);
      seed_save($seed);

      // Invoke hook_seed_use().
      module_invoke_all('seed_use', $seed);

      watchdog('seed', 'Successfully used seed @seedname for @username', array('@seedname' => $seed->name, '@username' => $account->name), WATCHDOG_NOTICE, l('user', 'user/' . $account->uid));

      return $seed;
    }
  }

  // Something went wrong.
  watchdog('seed', 'unable to use seed @sid for user @username', array('@sid' => $sid, '@username' => $user->name), WATCHDOG_CRITICAL, l('user', 'user/' . $user->uid));

  return FALSE;
}

/**
 * Returns a seed token.
 */
function seed_use_token($seed) {
  return substr(md5($seed->sid . '-' . $seed->uid . '-' . $seed->used_timestamp), 0, 16);
}

/**
 * Load a seed.
 *
 * @param $sid
 *   A Seed ID.
 * @param $is_held
 *   Only return a seed that is currently being held.
 * @return
 *   A Seed Object.
 */
function seed_load($sid, $is_held = FALSE) {
  $query = db_select('seed', 's')
    ->fields('s')
    ->condition('s.sid', $sid);

  // If looking for held seeds, add extra conditions.
  if ( $is_held ) {
    $query
      ->condition('s.used', 0)
      ->condition('s.status', 0);
  }

  return $query->execute()->fetchObject();
}

/**
 * Load all seeds for a taxonomy term.
 *
 * @param $tid
 *   A Term ID.
 * @return
 *   An array of Seed Objects.
 */
function seed_load_by_tid($tid) {
  $result = db_select('seed', 's')
    ->fields('s')
    ->condition('s.tid', $tid)
    ->execute()
    ->fetchAll();

  return $result;
}

/**
 * Saves a seed.
 */
function seed_save($seed) {
  $seed->is_new = empty($seed->sid);

  if ( !$seed->is_new ) {
    $status = drupal_write_record('seed', $seed, 'sid');
  }
  else {
    $status = drupal_write_record('seed', $seed);
  }

  return $status;
}

/**
 * Delete a seed.
 */
function seed_delete($sid) {
  if ( $seed = seed_load($sid) ) {
    $transaction = db_transaction();
    try {
      db_delete('seed')
        ->condition('sid', $seed->sid)
        ->execute();

      cache_clear_all();
      seed_static_reset();

      return SAVED_DELETED;
    }
    catch ( Exception $e ) {
      $transaction->rollback();
      watchlog_exception('seed', $e);
      throw $e;
    }
  }

  return FALSE;
}

/**
 * Clear all static cache variables for seeds.
 */
function seed_static_reset($ids = NULL) {
  drupal_static_reset('seed_load');
}

/**
 * Return the Vocabulary ID (vid) used by seed for categorization.
 */
function seed_get_vid() {
  if ( !module_exists('taxonomy') ) {
    return FALSE;
  }

  $vid = variable_get(SEED_CATEGORY_DEFAULT_VID, '');
  if ( empty($vid) || !taxonomy_vocabulary_load($vid) ) {
    $vid = db_query("SELECT vid FROM {taxonomy_vocabulary} WHERE module = 'seed'")->fetchField();
    if ( !$vid ) {
      drupal_set_message(t('Created Seed vocabulary'));

      $vocab = (object) array(
        'name' => SEED_CATEGORY_NAME,
        'description' => t('Automatically created by the seed module.'),
        'machine_name' => 'seed',
        'multiple' => FALSE,
        'required' => FALSE,
        'hierarchy' => TRUE,
        'relations' => FALSE,
        'module' => 'seed',
      );

      taxonomy_vocabulary_save($vocab);
      $vid = $vocab->vid;
      variable_set(SEED_CATEGORY_DEFAULT_VID, $vid);
    }
  }

  if ( !is_numeric($vid) ) {
    watchdog('seed', 'Seed module was unable to select or create a vocabulary.', array(), WATCHDOG_ERROR);
  }

  return $vid;
}